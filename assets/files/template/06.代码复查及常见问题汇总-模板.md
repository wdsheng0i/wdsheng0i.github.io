## 一、[XXX系统坏代码总结]-模板 
- 研发经理：
- 技术负责人：

### 问题标题
- 类名:
- 方法名:
- 代码：

``` 

```
- 逻辑描述：


- 问题：

- 改进：

- 提出人：

- 提出时间：

---

## 二、代码复查方法总结
### 2.1、人工复查忽略工具可以复查的问题
代码复查需要带着目标来查，人工复查不要过分关注可以采用自动化工具可以复查的部分，例如通过findbugs和checkstyle可以扫描出来的问题（当然复查人或者研发经理需要关注和推动findbugs问题和checkstyle问题的持续改进）。其中工具可以复查的问题总结如下：
- Dead store to local variable 本地变量存储了闲置不用的对象
- Load of known null value 可能会出现空指针异常
- Exception is caught when Exception is not thrown 捕获了异常但是try里并没有抛出异常
- Method ignores exceptional return value 没有对方法的异常返回值进行检查
- Comparison of String objects using == or !=
- Method names should start with a lower case letter
- Non-transient non-serializable instance field in serializable class
- 诸多格式问题
- [more](http://blog.csdn.net/aya19880214/article/details/42551903)

### 2.2、重点关注典型问题
典型问题是基于公司业务场景和类型总结出来的容易出现的代码问题，复查的时候可以有针对性的查找这方面问题

#### sql操作
- 1.接口返回批量数据的时候，必须做分页控制。避免一次返回上万条数据，效率低而且容易导致JVM内存溢出
- 2.在循环中（for、wihle），存在查询或更新数据库的脚本，将导致产生大量SQL的问题
- 3.在循环中（for、wihle），存在查询或更新数据库的脚本，且没有对垃圾数据进行处理，导致无限循环或一个跨度较大的循环，将导致产生大量SQL的问题
- 4.在一次业务处理中，反复从数据库装载同一对象，将导致产生重复大量SQL的问题
- 5.SQL脚本操作一批数据，是通过in来实现的，没有预估到in的个数量，导致拼接的SQL很长
- 6.SQL查询时，通过in来实现的，in中所传参数个数不超过100
- 7.SQL查询中，不能使用select * 进行查询
- 8.SQL查询时，条件语句中带or的话，很容易造成全表扫描。最好不要出现这样的sql，可以使用in、union、uion all 代替
- 9.sql查询数据量的时候，使用select查询明细，然后再通过Collection.getSize()获取数据量，会导致查询效率地下。要使用select count的方式
 
![](https://wdsheng0i.github.io/assets/images/2021/dev-tools/sql-gf.png)  

#### 集合使用问题
- 1.List的遍历，代码中要使用迭代器(foreach)而不是index
- 2.List集合选择，如果能预知集合大小，在初始化集合的时候应该设置集合大小，避免ArrayList动态扩容。如果无法预知集合大小，建议采用LinkedList
- 3.LinkedList禁止使用XXX.get(i)
- 4.Map遍历禁止使用keySet遍历，在循环体中用XXXMap.get(key)获取value，要使用entrySet进行遍历

#### 线程安全问题
- 1.关注spring bean中定义属性变量，关注Utils类中的静态变量的实例化伙计
- 2.关注缓存类的init，reload，get方法间的并发可能性
- 3.重点关注程序中出现new Thread，Executors的地方对创建线程，或者线程池的使用

#### redis使用
- 1.关注每次访问redis都重新创建和关闭连接，需要使用jedis连接池
- 2.关注程序是否一次从redis上下载大量数据
- 3.关注在for循环中操作redis

#### 日志记录
- 1.关注日志记录中是否合理使用了error、warn、info、debug等日志级别
- 2.关注日志的输出是否可以支撑后续问题排查和生成环境调试需求，需要输出的信息是否完整输出
- 恰当处理异常，准确记录日志，禁止异常信息打印到控制台
- 程序中禁止使用System.out或System.err或System.in

#### 流操作
- 1.关注正常、异常情况下流是否能正常关闭
- 使用IO流后要关闭，进行资源回收
- 文件处理，没有考虑到大文件，一次性申请大量的内存进行文件处理，导致内存溢出
- 文件处理时，要考虑到文件大小，避免内存溢出
- 文件/数据库/中间件编码统一采用UTF-8，字符串(文件流)处理过程中，要指明使用UTF-8编码

#### 字符串
- 字符串拼接要使用StringBuffer或StringBuilder

#### 原子操作添加事务

#### 禁用魔法数字

#### 圈复杂度 
- 方法圈复杂度不超过10
- 方法参数不超过5个

#### 类设计复查
- 关注类的实现是否符合单一职责原则，重点关注超过500行代码的实现类
- 关注代码的依赖是否需要遵循依赖倒置原则（根据业务需求是否会频繁变化作为判断依据）
- 关注代码的时候是否符合迪米特法则，重点复查多个类质检是否有A依赖B，同时B也依赖A的情况
- 关注接口或类方法中是否返回了List或者Map这样的数据（一个类可以依赖另一个类去实现一个业务逻辑，但是要避免依赖另一个类的数据结构）

### 2.3、公司规范复查
公司的技术规范规定了很多设计和开发方面的约束，有时候架构师或者设计人员对规范中已经规定了的部分在设计的时候可能不再赘述，代码复查的时候也要关注这部分规范的执行情况

- 1.增量设计实现，表结构中设计的增量字段在编码的时候是否考虑更新这些字段的值
- 2.接口规范的实现，代码复查的时候关注实现的接口是否按照改文档定义的接口结构组装数据，是否按照文档中规定的状态代码返回。

### 2.4、工具、框架复用类复查
代码复查的时候要关注代码中是否可以复用某些类库或公司的组件实现，避免重复劳动。  
即使已经实现，也应该通过代码复查的方式告诉对应编码人员有工具可以复用；  
重点关注commons-lang、commons-io包中的工具类的复用。

### 2.5、业务逻辑复查
没有彩蛋，对于核心模块，需要先熟悉业务逻辑，再根据业务逻辑走查代码，判断代码实现逻辑是否和预期一致。

### 2.6、安全问题复查
如果是互联网或者和别的公司的对接项目，还需要对接口、系统页面的安全性进行复查.
