---
layout: post
title: JVM、GC、类加载、运行时数据区域
category: jvm
tags: [jvm]
---

JVM、GC、类加载、运行时数据区域

## 参考资料
- [《深入理解Java虚拟机》]()
- [JVM 入门教程](https://www.5axxw.com/wiki/topic/3oaic1)

## 一、JVM虚拟机


## 二、JVM内存区域 


## 三、JVM运行时数据区域


## 四、JVM垃圾回收机制、内存分配策略
### 4.1 对象已死
    引用计数算法
    根搜索算法

### 4.2 垃圾收集算法
    标记 -清除算法
    复制算法
    标记-整理算法
    分代收集算法

### 4.3 垃圾收集器 
    Serial收集器 
    ParNew收集器 
    Parallel Scavenge收集器 
    Serial Old收集器 
    Parallel Old收集器 
    CMS收集器 
    G1收集器 

### 4.4 内存分配与回收策略 
    对象优先在Eden分配 
    大对象直接进入老年代 
    长期存活的对象将进入老年代 

## 五、JVM类加载机制
### 5.1 类加载的时机 

### 5.2 类加载的过程

### 5.3 类加载器 

### 5.4 双亲委派模型

### 5.5 破坏双亲委派模型


## 六、JVM内存模型JMM
### 6.1 Java内存模型

### 6.2 主内存与工作内存

### 6.3 volatile型变量
每次修改volatile变量的值后必须立刻同步回主内存，每次使用volatile变量前必须从主内存中刷新最新值  
![](https://wdsheng0i.github.io/assets/images/2021/juc/volatile.png)   
 
通过加入 内存屏障和 禁止重排序优化来实现可见性。具体实现过程：  
- 对 volatile变量写操作时，会在写操作后加入一条 store屏障指令，将本地内存中的共享变量值刷新到主内存
- 对 volatile变量读操作时，会在读操作前加入一条 load屏障指令，从主内存中读取共享变量
- volatile 不能保证操作的原子性，也就是不能保证线程安全性， 如果需要使用 volatile 必须满足以下两个条件：
- 对变量的写操作不依赖与变量当前的值。
- 该变量没有包含在具有其他变量的不变的式子中。

所以 volatile修饰的变量适合作为状态标记量。

### 6.4 原子性、可见性与有序性
原子性(Atomicity)：  
原子操作、提供互斥访问，同一时刻只能有一个线程对数据进行操作(Atomic、CAS算法、synchronized、Lock)，非原子操作都会存在失去cpu时间片的可能，存在线程安全问题
- 8种操作是原子操作：lock(锁定)、unlock(解锁)、read(读取)、load(载入)、use(使用)、assign(赋值)、store(存储)、write(写入)
- synchronized
- lock

可见性(Visibility)：  
一个主内存的线程如果进行了修改，可以及时被其他线程观察到(synchronized、volatile)  
- volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的
- synchronize 
- lock
- final也可以保证可见性，因为一旦初始化遍不可修改

有序性(Ordering)：  
- 指令重排序和工作内存与主内存同步延迟。这两个原因造成程序的书写顺序(单线程下串行的有序)与实际CPU的执行顺序(多线程下顺序是不可预测的)是不一致的；更深层次的原因就是硬件原因了：CPU为了优化性能，缓存与主内存的访问速度差异导致最终的顺序产生变化，最终造成有序性问题。  
- 如果两个线程不能从 happens-before原则 观察出来，那么就不能观察他们的有序性，虚拟机可以随意的对他们进行重排序  

volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，  
- volatile 是因为其本身包含“禁止指令重排序”的语义，  
- synchronized “一个变量在同一个时刻只允许一条线程对其进行 lock 操作”，此规则决定了持有同一个对象锁的两个同步块只能串行执行。
- lock

### 6.5 先行发生原则
这8条原则摘自《深入理解Java虚拟机》，前4条规则是比较重要的，后4条规则都是显而易见的
- 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
- 锁定规则：一个 unLock操作先行发生于后面对同一个锁的 Lock()操作，也就是说只有先解锁才能对下面的线程进行加锁
- volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
- 传递规则：如果操作A先行发生与操作B,而操作B先行发生于操作C，则操作A先行发生于操作C
- 线程启动规则： Thread对象的 start()方法先行发生于此线程的每一个动作，一个线程只有执行了 start()方法后才能做其他的操作
- 线程终端规则：对线程 interrupt()方法的调用先行发生与被中断线程的代码检测到中断事件的发生(只有执行了 interrupt()方法才可以检测到中断事件的发生)
- 线程终结规则：线程中所有操作都先行发生于线程的终止检测，我们可以通过 Thread.join()方法结束， Thread.isAlive()的返回值手段检测到线程已经终止执行
- 对象终结规则：一个对象的初始化完成先行发生于他的 finalize()方法的开始